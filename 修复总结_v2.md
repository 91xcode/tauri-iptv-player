# IPTV Player 修复总结 v2.0

## 🎯 问题描述

播放 IPv6 直播流时，**播放到 1 分钟后自动停止**。

## 🔍 根本原因

### 原始实现的问题

```typescript
// ❌ 错误的实现方式
1. 下载 IPv6 m3u8 文件（一次性）
2. 转换所有 URL 为代理 URL
3. 创建 Blob URL
4. 传给 HLS.js

问题：Blob URL 是静态的，不会更新！
直播流的 m3u8 需要定期刷新获取新的片段。
```

### 额外的干扰因素

```typescript
// ❌ 播放监控器（每 5 秒执行）
- 检测播放是否卡住 → 调用 hls.startLoad() → 重新加载整个流
- 检测延迟超过 30 秒 → 强制跳转 currentTime → 触发缓冲区重置
```

## ✅ 解决方案

### 1. 完全参考 x-iptv-player 的实现

**x-iptv-player (Electron) 的做法：**
- 直接将 URL 传给 HLS.js
- 在 Node.js 代理服务器中重写 m3u8 内容
- 不干预播放过程，让 HLS.js 自己处理

**我们的实现（Tauri）：**
- 前端：直接传代理 URL 给 HLS.js
- 后端：Axum 代理服务器重写 m3u8 内容
- 不干预播放过程

### 2. 前端修改

#### 之前（❌ 错误）：
```typescript
// 下载 m3u8
const content = await invoke("fetch_and_proxy_m3u8", { url });

// 手动重写 URL
const processedLines = content.split('\n').map(...);

// 创建 Blob URL（静态！）
const blob = new Blob([processedContent], { type: "..." });
const blobUrl = URL.createObjectURL(blob);

// 传给 HLS.js
hls.loadSource(blobUrl);
```

#### 现在（✅ 正确）：
```typescript
// 直接使用代理 URL（动态！）
if (isIpv6 && channel.url.includes(".m3u8")) {
  const encodedUrl = encodeURIComponent(channel.url);
  processedUrl = `http://127.0.0.1:18080/proxy?url=${encodedUrl}`;
}

// 传给 HLS.js
hls.loadSource(processedUrl);
```

### 3. 后端修改

在 Rust 代理服务器中添加 m3u8 重写逻辑：

```rust
// src-tauri/src/lib.rs
async fn proxy_handler(Query(params): Query<ProxyParams>) -> Result<Response, StatusCode> {
    // 获取原始内容
    let bytes = response.bytes().await?;

    // ⭐ 如果是 m3u8，重写内容
    let final_bytes = if params.url.contains(".m3u8") {
        let content = String::from_utf8(bytes.to_vec())?;

        // 解析 base URL
        let base_url = extract_base_url(&params.url);

        // 重写每一行
        let processed_lines: Vec<String> = content.lines().map(|line| {
            if line.starts_with('#') || line.is_empty() {
                return line.to_string();
            }

            // 相对路径 → 绝对路径
            let absolute_url = make_absolute(line, base_url);

            // ⭐ IPv6 URL → 代理 URL
            if absolute_url.contains('[') && absolute_url.contains(']') {
                let encoded = urlencoding::encode(&absolute_url);
                format!("http://127.0.0.1:18080/proxy?url={}", encoded)
            } else {
                absolute_url
            }
        }).collect();

        processed_lines.join("\n").into_bytes()
    } else {
        bytes.to_vec()
    };

    Ok(response)
}
```

### 4. 移除播放监控

```typescript
// ❌ 删除
const startProgressMonitor = () => {
  progressCheckIntervalRef.current = window.setInterval(() => {
    // 检查卡住、延迟等 → 干预播放
  }, 5000);
};

// ✅ 让 HLS.js 自己处理
// 不需要任何监控逻辑
```

### 5. 优化 HLS.js 配置

```typescript
const hls = new Hls({
  // 超时配置（大幅增加）
  fragLoadingTimeOut: 60000,        // 60 秒
  manifestLoadingTimeOut: 30000,    // 30 秒
  levelLoadingTimeOut: 30000,       // 30 秒

  // 重试配置（增加次数）
  manifestLoadingMaxRetry: 6,       // 6 次
  levelLoadingMaxRetry: 6,          // 6 次
  fragLoadingMaxRetry: 8,           // 8 次

  // Buffer 配置（大容量）
  maxBufferLength: 30,              // 30 秒
  maxMaxBufferLength: 60,           // 60 秒
  backBufferLength: 30,             // 30 秒
  maxBufferSize: 120 * 1000 * 1000, // 120 MB

  // 稳定性优先
  lowLatencyMode: false,            // 关闭低延迟模式
});
```

### 6. 智能错误处理

```typescript
hls.on(Hls.Events.ERROR, (_event, data) => {
  // ⭐ 智能过滤：忽略非致命错误
  const ignorableErrors = [
    'fragLoadError',
    'fragLoadTimeOut',
    'levelLoadTimeOut',
    // ...
  ];

  if (!data.fatal && ignorableErrors.includes(data.details)) {
    return; // 让 HLS.js 自动处理
  }

  // 只处理致命错误
  if (data.fatal) {
    // 指数退避重试
    const delay = Math.min(1000 * Math.pow(2, retryCount), 10000);
    setTimeout(() => {
      if (data.type === 'NETWORK_ERROR') {
        hls.startLoad();
      } else if (data.type === 'MEDIA_ERROR') {
        hls.recoverMediaError();
      }
    }, delay);
  }
});
```

## 🎬 工作流程对比

### 之前（❌）：
```
1. 前端请求 Tauri 命令下载 m3u8
   ↓
2. Tauri 下载 m3u8 返回给前端
   ↓
3. 前端重写 URL，创建 Blob
   ↓
4. HLS.js 加载 Blob URL（静态，不会更新）
   ↓
5. ❌ 播放 1 分钟后停止（m3u8 没有新片段）
```

### 现在（✅）：
```
1. 前端直接传代理 URL 给 HLS.js
   ↓
2. HLS.js 请求: http://127.0.0.1:18080/proxy?url=原始m3u8
   ↓
3. Rust 代理服务器获取 m3u8
   ↓
4. 重写内容（所有 URL → 代理 URL）
   ↓
5. 返回处理后的 m3u8 给 HLS.js
   ↓
6. HLS.js 解析，请求 .ts 片段（也通过代理）
   ↓
7. HLS.js 定时刷新 m3u8（获取新片段）
   ↓
8. ✅ 持续稳定播放（无时间限制）
```

## 📊 修复效果

| 指标 | 修复前 | 修复后 |
|------|--------|--------|
| **播放时长** | ~1 分钟 | ✅ 无限制 |
| **m3u8 刷新** | ❌ 静态 Blob | ✅ 动态更新 |
| **错误恢复** | ❌ 基础 | ✅ 智能过滤 + 指数退避 |
| **缓冲区** | 10 秒 | 30-60 秒 |
| **超时时间** | 20 秒 | 60 秒 |
| **重试次数** | 4 次 | 6-8 次 |

## 🔑 关键代码位置

### 前端
- **VideoPlayer.tsx (61-75 行)**: IPv6 URL 处理
- **VideoPlayer.tsx (140-175 行)**: HLS.js 配置
- **VideoPlayer.tsx (260-320 行)**: 错误处理

### 后端
- **lib.rs (490-580 行)**: 代理服务器实现
- **lib.rs (545-575 行)**: m3u8 URL 重写逻辑
- **lib.rs (590-600 行)**: 代理服务器启动

## 🎓 技术要点

1. **动态 vs 静态 URL**
   - Blob URL：静态，适合一次性资源
   - 代理 URL：动态，HLS.js 会定时刷新

2. **不要干预 HLS.js**
   - HLS.js 有完善的错误处理和重试机制
   - 过度监控反而会导致问题

3. **代理服务器的关键作用**
   - 重写 m3u8 内容（URL 转换）
   - 注入请求头（User-Agent、CORS 等）
   - 支持 IPv6（Reqwest 自动处理）

4. **指数退避重试**
   - 避免频繁重试导致服务器压力
   - 给网络问题恢复的时间

## 📚 参考资料

- [x-iptv-player](https://github.com/xxx/x-iptv-player) - 主要参考项目
- [HLS.js 文档](https://github.com/video-dev/hls.js/blob/master/docs/API.md)
- [Axum 官方示例](https://github.com/tokio-rs/axum/tree/main/examples)

---

**修复日期：** 2025-01-25
**修复版本：** v1.1.0
